线程池

核心线程、非核心线程、等待队列等有何含义

线程池如何复用线程

几种线程池的选择及实现

<img src="https://www.pdai.tech/_images/thread/java-thread-x-juc-executors-1.png" alt="类结构关系" style="zoom:100%;" />

主要的类：

- ThreadPoolExecutor
- ScheduledThreadExecutor

## ThreadPoolExecutor

- 为什么要有线程池？

  - 提升性能
  - 减少线程频繁的创建与销毁
  - 提高线程的可管理性

- Java实现和管理线程池有哪些方式？

- 为什么不允许使用Executors去创建线程池？推荐的方式是什么？

- ThreadPoolExecutor的核心配置参数有哪些？作用分别是什么？

  coreThreadSize、最大线程数、等待队列、拒绝策略

- ThreadPoolExecutor可以创建哪三种线程池？

  - newFixedThreadPool(核心线程数和线程总数一致，使用LinkedBlockingQueue无界阻塞队列)

    缺点：无界队列，一直添加任务可能会出现OOM

  - newSingleThreadExecutor

    只有一个核心线程，使用无界阻塞队列，任务执行是串行的

    缺点：无界队列

  - newCachedThreadPool

    ```java
    ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                        60L, TimeUnit.SECONDS,
                                        new SynchronousQueue<Runnable>());
    ```

    特点：核心线程数为0，线程总数是Int的最大值，空闲时间60s，

- 线程超过最大线程数会发生什么？触发RejectedExecutionHandler

- ThreadPoolExecutor有哪些RejectedExecutionHandler策略？默认策略是什么？

- 简要说下线程池的任务执行机制?

- 线程池中任务如何提交？submit

- 线程池中任务如何关闭？shutDown,

- 配置线程池需要考虑哪些因素？

- 如何监控线程池状态

## 线程池是如何做到线程复用的

每个Worker代表一个线程，开启后会不断从workQueue任务队列里获取任务，如果workQueue为空，就阻塞等待直到workQueue有任务

- addWorker：添加线程并启动，非为核心和非核心，会不断从任务队列拿取任务
- 

ThreadPoolExecutor

- corePoolSize：核心线程数

- maxiumPoolSize：最大线程数

- keepAliveTime和Unit：空闲线程回收的时间以及单位

- workQueue：阻塞队列

- threadFactory：创建线程的Factory，默认是DefautlFactory，可以设置线程的名称，是否为守护线程，优先级

- handler：拒绝策略，线程超过最大线程数时。

  分类：

  AbortPolicy：默认策略，直接抛出异常

  CallerRunsPolicy：在调用者线程执行任务

  DiscardOldestPolicy：抛弃最老的一个任务，把新的添加进去

  DiscardPolicy：丢弃，不抛异常

SynchronzExecutor

关键点：

addWorker->runWorker->执行firstTask，然后在while里不断从workQueue里取出task执行，直到workQueue为空为止

这个怎么处理核心线程和非核心线程的特殊之处呢？

解决：其实没有区分核心线程还是非核心线程，是否回收是根据getTask的局部变量timed来决定的，那在getTask里做了什么处理呢？

步骤1：如果允许核心线程回收或线程数大于核心线程数，timed设为true

步骤2：线程可回收（超过最大线程数或有存活时间且时间到了），用CAS将线程数减1返回空

步骤3：从workQueue获取任务，任务为null，没任务了，设timedOut=true

1->3-1>2

## 阻塞队列BlockingQueue

作用

实现原理（源码分析）：

实现了生产者-消费者模型：添加时，在while判断池子是否满了，满了就调用await释放锁，等待消费者消费了池子不满才放进去，放进去后唤醒所有等待的；消费者：while里判断池子是不是空的，空的话就wait等待池子不空，消费完后唤醒所有等待的->为什么要用while，在多生产者/消费者的情况下，你获得到的锁的时候其他人可能已经处理过了，这时候条件可能就不符合了

获取任务->没有一直阻塞

​				  有，返回

ArrayBlockingQueue

- 用数组存储任务，任务总数固定

LinkedBlockingQueue

- 链表存储任务，不指定情况下任务总数为Interger.MAX_VALUE
- 不对数量做限制，可能会出现OOM

SynchronousQueue

- 只能存储一个任务，所以任务是一个一个执行的

PriorityBlockingQueue

- 按优先级对队列排序