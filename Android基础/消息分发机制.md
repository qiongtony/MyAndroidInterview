# 消息分发机制

## ThreadLocal

是代理类，真正value的存储不是在ThreadLocal，而是在当前Thread.ThreadLocalMap里,这样保证不会出现内存泄漏，因为value的生命周期与Thread一致，而且持有的ThreadLocal是弱引用

我们一般实现的结构图：
![一般认为的结构图](https://static001.geekbang.org/resource/image/6a/34/6a93910f748ebc5b984ae7ac67283034.png)

**缺陷：ThreadLocalMap持有线程的强引用，如果不在销毁时及时remove，容易造成内存泄漏**

实际的结构图
![ThreadLocal内部结构图](https://static001.geekbang.org/resource/image/3c/02/3cb0a8f15104848dec63eab269bac302.png)

### ThreadLocal在线程池中的内存泄漏

原因分析：线程池中的线程有可能被复用，导致存储强引用的value无法被回收

解决方案：任务执行完后手动调用threadLocal.remove

```java
ExecutorService es;
ThreadLocal tl;
es.execute(()->{
  //ThreadLocal增加变量
  tl.set(obj);
  try {
    // 省略业务逻辑代码
  }finally {
    //手动清理ThreadLocal 
    tl.remove();
  }
});
```

## epoll机制

I/O多路复用：