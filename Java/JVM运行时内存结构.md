# JVM

- JVM运行时内存结构
- 垃圾回收
- class文件结构
- 编译插桩

# 一、JVM运行时内存结构

线程共享：

- 方法区

  已加载的类信息、常量、静态变量、即时编译器编译后的代码的数据等，被称为永生代

- 堆

  对象的实例、数组，是**Java垃圾收集器**管理的主要区域，也被成为GC堆

  内存划分：新生代（Eden、Survivor）、老年代

线程私有：

- 本地方法栈

  与虚拟机栈基本一致，只不过是针对native方法

- 虚拟机栈

  出现的异常：

  StackOverflowError:栈溢出

  OutOfMemoryError：内存溢出

  含义：JVM用来描述方法运行的内存模型 ，每个方法被执行，都被在虚拟机栈创建一个栈帧

  - 栈帧

    虚拟机调用和执行方法的数据结构（表示调用，并存执行需要的数据）

    包含的数据：

    - 局部变量表（形参和方法内的局部变量以及它的数量）
    - 操作数栈（存储数据和字节码指令）
    - 动态连接：调用方法时，将方法的**符号引用***转化为内存的**直接引用**，达到支持及动态链接
    - 返回地址：返回到方法被调用的位置

- 程序计数器

  作用：记录代码执行的位置，方便重新执行时的恢复

  要点：

  - 在JVM规范中，不会出现OOM
  - 线程创建而创建，线程结束而销毁
  - 线程 在执行Java方法，记录的是虚拟机字节码指令的地址，执行Native方法，计数器值为空

