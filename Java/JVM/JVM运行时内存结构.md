# JVM

- JVM运行时内存结构
- 垃圾回收
- class文件结构
- 编译插桩

# 一、JVM运行时内存结构

线程共享：

- 方法区

  特点：JVM规范里规定的一块运行时数据区

  存储已被加载的类信息、常量、静态变量、即时编译器编译后的代码的数据等，主要是常量池（如String，基本数据类型的缓存？）被称为永生代

- 堆

  特点：

  - JVM所管理的内存最大的一块
  - 存放几乎所有对象的实例
  - **Java垃圾收集器**管理的主要区域，也被成为GC堆

  根据存储时间，内存可划分为：新生代（Eden、Survivor）、老年代

线程私有：

- 本地方法栈

  与虚拟机栈基本一致，只不过是针对native方法

- 虚拟机栈

  出现的异常：

  StackOverflowError:栈溢出

  OutOfMemoryError：内存溢出

  含义：JVM用来描述方法运行的内存模型 ，每个方法被执行，都会在虚拟机栈创建一个栈帧

  - 栈帧

    虚拟机调用和执行方法的**数据结构**（表示调用，并存执行需要的数据）

    包含的数据：

    - 局部变量表（形参和方法内的局部变量）：基本数据类型、对象引用、returnAddress类型
    
    - 操作数栈（存储字节码指令）
    
    - 动态连接
    
      目的：支持方法调用过程中的动态连接
    
      调用其他方法时，将方法的**符号引用**转化为内存中的**直接引用**，达到支持及动态链接
    
    - 返回地址：返回到方法被调用的位置

- 程序计数器

  作用：记录字节码代码执行的位置，方便重新执行时的恢复

  存在的原因：CPU分片执行，进行线程切换

  要点：
  
  - 在JVM规范中，不会出现OOM
  - 线程创建而创建，线程结束而销毁
  - 线程在执行Java方法，记录的是虚拟机字节码指令的地址，执行Native方法，计数器值为空

## 对象的内存布局

对象头、实例数据和对齐填充（必须是8字节的整数数）

对象头：（两者在32/64占的字节是一样的）

- markword：32位4字节、64位系统8字节---锁存在着

- 类型指针：32位4字节、64位系统8字节，开启压缩4字节

实例数据：成员变量（基本数据类型和引用对象）

类型 | 内存（字节)
---|---
boolean/byte | 1
short/char | 2
int float | 4
long /double | 8

对齐填充：对象占用空间必须是8字节的倍数，所以需要进行对其

![](https://upload-images.jianshu.io/upload_images/5401975-4c082ac80e1c042c.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

# 二、垃圾回收

含义：将**已分配不使用**的内存**回收**，方便再次分配

垃圾回收的关键：**识别定位垃圾，如何处理垃圾**

## 如何确定不可用？

- 引用计数法

  含义：每个对象添加一个引用计数器，计数器为0说明不可达

  缺点：无法解决循环引用

- 可达性分析法

  含义：从GC Root开始找有没有通发该对象的路径，如果有说明对象还存活，没有说明对象已死亡

  - GC Root：可以简单理解为**堆外指向堆内的引用**（说法不全面）---只需要看看内存结构哪里可能指向就行了。包括但不限于：（**三个运行时内存结构中的引用和线程对象**）
    - 方法区中静态对象指向的引用
    - Java虚拟机栈（**局部变量表**）引用的对象
    - Native方法中JNI引用的对象
    - 存活状态中的线程对象

不同的收集：

- 新生代收集：Minor GC/Young GC
- 老年代收集：Magjor GC/Old GC
- 混合收集（Mixed GC）：新生代和部分老年代的垃圾收集，只有G1收集器会有这种行为
- 整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集

## 垃圾回收算法

### 标记-清除算法

过程：标记已死亡的对象，回收该已死亡对象

<img src="https://cdn.nlark.com/yuque/0/2020/png/1121060/1608773713070-c2b7134f-4bac-4421-ae74-30dd58b84870.png?x-oss-process=image%2Fresize%2Cw_653" alt="标记-清除" style="zoom:100%;" />)

优点：原理简单，效率高

缺点：

- 容易产生内存碎片
- 分屏效率低

### 标记复制算法

与标记清除类似，只是把内存分为两份，每次只处理一边，假设为A，记录下存活的对象，将这些对象按顺序移到B，清空A的内存

优点：实现简单、运行高效，不会存在内存碎片

缺点：堆空间使用率低

### 标记整理算法

对标记清除算法的优化，会对存活对象进行整理

优点：堆内存使用率高

缺点：效率受整理算法影响

针对的场景：对象存活率较高

## 分带回收策略

原因：大部分Java对象存活时间短用后就没用了，小部分对象存活很长时间

So，为了提高回收效率，采用分代及分代进行使用不同回收算法的策略

分带：

- 新生代

  细分为：

  - 1个Eden（8）
  - 2个Survivor（1），分别为S0和S1

- 老年代

### 新生代垃圾回收算法

特点：Java对象存活时间短->回收的数量多

使用标记复制算法

对Eden和S1的对象进行标记，存活的对象复制到S0，清空Eden和S1，执行2；

对Eden和S0的对象进行标记，存活的对象赋值到S1，清空Eden和S0，执行1；

其中经过多次的回收，存活的对象会被移到老年代

注意：

如果对象比较大且新生代剩余空间不足，则会直接被分配到老年代上

### 老年代垃圾回收算法

特点：Java对象存活时间长->回收的数量少

一般使用标记整理算法

>  注意：老年代中的对象如果引用到新生代对象，这个引用也会被作为GC Roots。但这时如果执行新生代GC，可能需要查询整个老年代上存在的新生代引用，显然是低效的->老年代维护了一个512 byte的**Card Table**，所有老年代对象引用新生代的信息都记录在这，这样就不需要查询整个老年代了，提高了性能

# 三、class文件结构

在JVM运行的不是java文件，而是.class，字节码

为什么？

Java是高级语言，机器无法直接识别，需要编译成字节码文件，JVM才能识别指令并运行---相当于翻译

字节码本质是二进制流，按照严格的顺序排列

Classw文件的结构

- 无符号数

- 表：包含无符号数和表

  类别View和ViewGroup

## Class文件结构

- 魔数：代表文件的类型
- 版本号
- 常量池
- 访问标志
- 类索引、父类索引、接口索引
- 

# 类加载机制

对象相同：

全限定名一致、用同一个类加载器加载

类加载器分类：

1. 启动类加载器BoostrapClassLoader

   加载的类：jre/lib下的rt.jar、resources.jar、charsets.jar和class等

2. Extention ClassLoader标准扩展类加载器

   加载的类：jre/lib/ext下的class和jar

3. Application ClassLoader 应用类加载器

   当前应用classPath下的类

4. User ClassLoader 用户自定义类加载器

双亲委托

定义：类加载器收到加载请求时不会立即加载，而是委托给父类加载，父类无法加载自己才尝试加载，加载成功，放到缓存中，不成功抛出ClassNotFoundException---递归的过程

优点：

- 防止系统类在内存中出现多份同样的字节码
- 保证Java程序安全稳定运行

父子加载器之间是继承关系吗？组合关系

loadClass的步骤：

1. 检查类是否已加载过
2. 没有加载，调用父加载器的loadClass方法进行加载
3. 若没有父加载器使用启动类加载器作为父加载器
4. 如果父类加载失败，抛出ClassNotFoundException后，调用自己的findClass方法进行加载

# 垃圾收集器

垃圾收集算法：指导思想

垃圾收集器：实际执行的工具

> 并行与并发
>
> 并行：多条垃圾收集线程之间的关系，同一时间，多条线程都在执行，工作线程默认等待
>
> 并发：垃圾收集器线程与工作线程共同执行，同一时间，两者都在运行

并行：

- Serial收集器

  单线程，执行时工作线程暂停，“Stop the world”

  特点：内存消耗最小

- ParNew

  Serial收集器的多线程并行版本

- Parallel Scavenge收集器

  特点：关注的是达到一个可控制吞吐量

> 吞吐量=运行用户代码时间/(运行用户代码时间+运行垃圾收集时间)

- Serial Old收集器

  Serial收集器的老年代版本

- Parallel Old收集器

  Parallel Scavenge收集器的老年代版本

- CMS收集器

  特点：获取最短回收停顿时间

  步骤

  - 初始标记

  - 并发标记

  - 重新标记

  - 并发清除

  初始标记和重新标记需要暂停工作线程，并发标记和并发清除与工作线程并发进行
  
  缺点：
  
  虽是并发，但会影响吞吐量，导致应用程序变慢